# Wealth.com Backend-focused Take-home Assignment

## Submission by Diego Huang

## Components within the submission

The submission is mainly composed
- `app.py`: Flask backend code
- `Dockerfile` for the Flask backend container
- `compose.yaml` which starts up two containers: one for the Flask backend and one for the MySQL database server
- `import_db.sh` which creates the database and table, and inserts the asset data into the table
- `asset_orm.py` which uses SQLAlchemy to map the database table to a Python object. This is used to create the table and select/insert rows.

The APIs are:
```
GET /assets : lists all assets, including all historical ones
POST /assets: adds a new asset entry

GET /assets/<asset_id> : gets the latest version of the asset identified by asset_id
GET /assets/<asset_id>?asOf=<datetime> : gets the version of asset\_id on or before datetime
```
## Design choices/Tradeoffs:

### Setting of balanceAsOf time

To add an asset, the `balanceAsOf` is assumed to be passed to the API in the body, as opposed to having the API use its own current time.
This is because the server time could be inaccurate, and the clock between the various systems may be different. Therefore, the time
should be generated by an authoritative timing source.
Another advantage of the API taking `balanceAsOf` as a parameter is that the API can also be used to backfill old entries.

### Creation of assetId

For new assets, the `assetId` ia also assumed to be passed to the API, instead of being generated by this API. The reason is because we need 
to guarantee that the IDs are globablly-unique, and this backend service (which may be part of a large fleet), cannot guarantee that the IDs
that it generates will be globablly unique.

### `GET /assets` could return only the latest versions of each asset, instead of all historical ones

An argument could be made to have `GET /assets` only return the latest version of each asset, instead of everything in the database. One way
to implement this is to have a subquery to get the latest date for all assetId's, and an outer query to fetch the entire row for those dates.

### Pagination of `GET /assets`

I ran out of time to implement pagination for the `GET /assets` call. The call will likely return a lot of data in production, and hence
returning a cursor for pagination would be a good idea to ensure that the API returns quickly and the database is not overloaded returning a giant
dataset.

### Data Validation

There is not much input data validation due to running out of time, but some places that would be good to have validation are:
- inputs used to create new asset entry in `POST /assets`
- date format of asOf parameter 

### Usage of SQLAlchemy

The code uses SQLAlchemy for mapping between Python objects and the database. It may seem overkill, but I like it because:
- it is database agnostic (I don't have to worry too much about database-specific annoyances)
- with one object mapping, I can create the necessary table, read and write data, and get free data validation. It's very convenient, though
  it does take some initial effort to write the mapping.
- I find it's more pythonic than writing raw SQL
  
## How to run

> [!IMPORTANT]
> Please copy the assets.json file into the git directory. I did not upload the data to the git repository so that the data doesn't get leaked to other candidates.

To build the Docker container:
```console
docker compose build
```

To start the database server and Flask backend:
```console
docker compose up
```

Then initialize the database:
```console
./import_db.sh
```

Then to exercise the GET requests, you can point your browser to
http://localhost:8000/assets
to get the list of all assets
and
http://localhost:8000/assets/qJfnKleFCUW6rlYsKEGiEA
to get the latest version of a specific asset with asset id `qJfnKleFCUW6rlYsKEGiEA` for example.

To get an earlier version of the asset, the asOf query parameter can be used, such as:
http://localhost:8000/assets/qJfnKleFCUW6rlYsKEGiEA?asOf=2025-03-29T00:00:00
If there are no earlier versions of the asset, a 404 error is returned.

To exercise the POST request, I use Postman to submit a POST request to
`localhost:8000/assets`
with a `Content-Type: application/json` header
and a json body such as:
```json
{
  "assetDescription": null,
  "assetId": "qJfnKleFCUW6rlYsKEGiEA",
  "assetInfo": "{\"nickname\":\"Cash Test\",\"descriptionEstatePlan\":\"\",\"estimateValue\":5000,\"purchaseCost\":0,\"asOfDate\":\"2025-03-28T15:55:22+00:00\",\"isFavorite\":false}",
  "assetInfoType": "ManualCash",
  "assetMask": null,
  "assetName": null,
  "assetOwnerName": null,
  "balanceAsOf": "2025-03-29T15:55:22+00:00",
  "balanceCostBasis": 0.0,
  "balanceCostFrom": "UserManual",
  "balanceCurrent": 5000.0,
  "balanceFrom": "UserManual",
  "balancePrice": null,
  "balancePriceFrom": "UserManual",
  "balanceQuantityCurrent": 5000.0,
  "beneficiaryComposition": null,
  "cognitoId": "d92f061e-a6b4-4292-97ab-3fd76d4e3442",
  "creationDate": "2025-03-28T15:55:22+00:00",
  "currencyCode": null,
  "deactivateBy": null,
  "descriptionEstatePlan": "",
  "hasInvestment": null,
  "holdings": null,
  "includeInNetWorth": true,
  "institutionId": 101,
  "institutionName": null,
  "integration": null,
  "integrationAccountId": null,
  "isActive": true,
  "isAsset": true,
  "isFavorite": false,
  "isLinkedVendor": null,
  "lastUpdate": "2025-01-01T15:55:22+00:00",
  "lastUpdateAttempt": "2025-03-28T15:55:22+00:00",
  "logoName": null,
  "modificationDate": "2025-03-28T15:55:22+00:00",
  "nextUpdate": null,
  "nickname": "Cash Test",
  "note": null,
  "noteDate": null,
  "ownership": null,
  "primaryAssetCategory": "Cash",
  "status": null,
  "statusCode": null,
  "userInstitutionId": "i7zh3OMH4UOEjbj2xuHMkw",
  "vendorAccountType": null,
  "vendorContainer": null,
  "vendorResponse": null,
  "vendorResponseType": "Other",
  "wealthAssetType": "Cash",
  "wid": "ae0df17e-514e-4f52-a0b5-5bfb1adf84c9"
}
```
